# -*- coding: utf-8 -*-
"""UB-SCL.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rbifbWonGNjO_mw1NX604Jg01Basdjlw

# **Universal Bank Loan Analysis using Super Machine Learner model**
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
import zipfile

from sklearn.model_selection import KFold
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.neighbors import KNeighborsClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.tree import DecisionTreeClassifier
from sklearn.svm import SVC
from sklearn.naive_bayes import GaussianNB
from sklearn.ensemble import AdaBoostClassifier
from sklearn.ensemble import BaggingClassifier
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.neural_network import MLPClassifier

zip = zipfile.ZipFile('archive.zip')
zip.extractall()

def Loan(df):
  for i in range(len(df)):
    if df['Mortgage'][i]!=0 and (df['Online'][i]==0 or df['CreditCard'][i]==0 or df['CD Account'][i]==0 or df['Securities Account'][i]==0):
       df['Loan/Debt'][i]=1
    else:
       df['Loan/Debt'][i]=0
  return df

df=pd.read_csv("UniversalBank.csv")
df['CCAvg']=round(df['CCAvg']).astype(int)
df=df.drop(columns=['ID','ZIP Code'])
df['Loan/Debt']=0
df=Loan(df)
df=df.dropna(how='any')
df

X=df.iloc[:,:-1].values
y=df.iloc[:,-1].values

y=y.reshape(len(y),1)

def get_models():
  models=list()
  models.append(LogisticRegression(solver='liblinear'))
  models.append(DecisionTreeClassifier())
  models.append(SVC(gamma='scale', probability=True))
  models.append(GaussianNB())
  models.append(KNeighborsClassifier())
  models.append(AdaBoostClassifier())
  models.append(BaggingClassifier(n_estimators=10))
  models.append(RandomForestClassifier(n_estimators=10))
  models.append(ExtraTreesClassifier(n_estimators=10))
  models.append(MLPClassifier(alpha=0.01, batch_size=256, epsilon=1e-08, learning_rate='adaptive', max_iter=500))
  return models

def get_out_of_fold_predictions(X, y, models):
	meta_X, meta_y = list(), list()
	# define split of data
	kfold = KFold(n_splits=10, shuffle=True)
	# enumerate splits
	for train_ix, test_ix in kfold.split(X):
		fold_yhats = list()
		# get data
		train_X, test_X = X[train_ix], X[test_ix]
		train_y, test_y = y[train_ix], y[test_ix]
		meta_y.extend(test_y)
		# fit and make predictions with each sub-model
		for model in models:
			model.fit(train_X, train_y)
			yhat = model.predict_proba(test_X)
			# store columns
			fold_yhats.append(yhat)
		# store fold yhats as columns
		meta_X.append(np.hstack(fold_yhats))
	return np.vstack(meta_X), np.asarray(meta_y)

def base_models(X_train,y_train,models):
  print("Models initialised")
  for i in range(len(models)):
    models[i].fit(X_train,y_train)
    print("{} model training completed".format(str(models[i])))
  print("models construction completed")

def fit_meta_model(X_train, y_train):
	model=MLPClassifier(alpha=0.01, batch_size=256, epsilon=1e-08, learning_rate='adaptive', max_iter=500)
	model.fit(X_train, y_train)
	return model

def evaluate_models(X_test, y_test, models):
	for model in models:
		yhat = model.predict(X_test)
		acc = accuracy_score(y_test, yhat)
		print('%s: %.3f' % (model.__class__.__name__, acc*100))

def super_learner_predictions(X, models, meta_model):
	meta_X = list()
	for model in models:
		yhat = model.predict_proba(X)
		meta_X.append(yhat)
	meta_X = np.hstack(meta_X)
	# predict
	return meta_model.predict(meta_X)

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25,random_state=42)

print('Train', X_train.shape, y_train.shape, 'Test', X_test.shape, y_test.shape)

models = get_models()

meta_X, meta_y = get_out_of_fold_predictions(X, y, models)

print('Meta ', meta_X.shape, meta_y.shape)

base_models(X_train, y_train, models)

meta_model = fit_meta_model(meta_X, meta_y)

evaluate_models(X_test, y_test, models)

yhat = super_learner_predictions(X_test, models, meta_model)
print('Super Learner: %.3f' % (accuracy_score(y_test, yhat) * 100))